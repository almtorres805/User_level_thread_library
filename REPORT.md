# User-level Thread Library
## Queue Implementation
Our queue data structure follows a doubly linked list implementation because we needed to ensure O(1) operations for managing the threads in the queue. To accomplish this we defined two structs to populate our queue. The first struct is called "node," which contains the address of a thread and a pointer to the next node. The node structure is a substructure of our queue structure. The “queue” struct internally holds the current size of the queue and two nodes: the front (oldest) node and the rear (newest) node.

Each function in the queue handles error management at the beginning. If the inputted queue, data, or allocated space has a value of NULL, the function returns -1. A return value of 0 indicates success.

The following design allowed for executing the enqueue, dequeue, and length functions in O(1) time. Having access to the rear pointer the enqueued node is appended to the front of the most recent node, and the rear pointer is updated. Similar to the rear, when a dequeue operation was called we would update the front node to point to where the current front’s next pointed to (second oldest node). However, there are two edge cases if both functions are called when the queue is empty. If a node is enqueued in an empty queue then the rear and front should both point to it. If the last node is dequeued then the rear should be NULL to ensure the queue's reliability. Additionally, we used the queues internal counter to appropriately update the length each time the enqueue, dequeue, or delete functions were called.

An exception to the O(1) constraints were the delete and iterate functions, which required the queue to be iterated resulting in O(N) time. Deleting a node in the middle/end of the queue follows a similar concept to dequeuing. Deleting a node from the front results in O(1) time because we just need to simply point the front to where the deleted node pointed to (second oldest). The iterate function is relatively simple. It iterates through each node in the queue and passes the required arguments to the user-defined callback function. This function is designed to be resistant to deletion, meaning that if a node is deleted within the callback function, a segmentation fault won't occur because the function avoids calling dereferenced deleted nodes.

### Not Finished yet
To ensure the proper functionality of our queue implementation, we designed a comprehensive set of tests that cover key aspects of the queue operations. We wanted to ensure the test functions handled edge cases appropriately, and reliable and efficient queue operations.
